name: Update YouTube Playlist

on:
  schedule:
    # 1日1回実行（午前9時 JST）
    - cron: '0 0 * * *'
  workflow_dispatch:
    # 手動実行も可能
    inputs:
      force_update:
        description: 'Force update playlist even if no changes detected'
        required: false
        default: 'false'
        type: boolean

permissions:
  contents: write
  pull-requests: write

jobs:
  update-playlist:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Create playlist update script
        run: |
          cat > update-playlist.mjs << 'EOF'
          import fs from 'fs';
          import path from 'path';
          
          const API_KEY = process.env.YOUTUBE_API_KEY;
          const PLAYLIST_ID = process.env.YOUTUBE_PLAYLIST_ID;
          
          if (!API_KEY || !PLAYLIST_ID) {
            console.error('API_KEY or PLAYLIST_ID is not set');
            process.exit(1);
          }
          
          const PLAYLIST_API_URL = `https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&maxResults=6&playlistId=${PLAYLIST_ID}&key=${API_KEY}`;
          
          async function updatePlaylist() {
            try {
              console.log('Fetching playlist data...');
              const response = await fetch(PLAYLIST_API_URL);
              const data = await response.json();
              
              if (!response.ok) {
                console.error('API Error:', data);
                process.exit(1);
              }
              
              // 動画IDを取得
              const videoIds = data.items.map(item => item.snippet.resourceId.videoId);
              
              // 各動画の詳細情報を取得（実際のチャンネル名のため）
              console.log('Fetching video details for actual channel names...');
              const videoDetailsUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${videoIds.join(',')}&key=${API_KEY}`;
              const videoDetailsResponse = await fetch(videoDetailsUrl);
              const videoDetailsData = await videoDetailsResponse.json();
              
              if (!videoDetailsResponse.ok) {
                console.error('Video Details API Error:', videoDetailsData);
                process.exit(1);
              }
              
              // プレイリストアイテムと動画詳細をマージ
              const playlistItems = data.items.map(item => {
                const videoDetail = videoDetailsData.items.find(video => video.id === item.snippet.resourceId.videoId);
                return {
                  id: item.id,
                  title: item.snippet.title,
                  channelTitle: videoDetail ? videoDetail.snippet.channelTitle : item.snippet.channelTitle, // 実際のチャンネル名を使用
                  thumbnail: item.snippet.thumbnails.medium.url,
                  publishedAt: item.snippet.publishedAt,
                  videoId: item.snippet.resourceId.videoId
                };
              });
              
              // publicディレクトリが存在しない場合は作成
              const publicDir = path.join(process.cwd(), 'public');
              const dataDir = path.join(publicDir, 'data');
              
              if (!fs.existsSync(publicDir)) {
                fs.mkdirSync(publicDir, { recursive: true });
              }
              
              if (!fs.existsSync(dataDir)) {
                fs.mkdirSync(dataDir, { recursive: true });
              }
              
              // プレイリストデータをJSONファイルに保存
              const outputPath = path.join(dataDir, 'playlist.json');
              fs.writeFileSync(outputPath, JSON.stringify(playlistItems, null, 2));
              
              console.log(`Playlist data updated successfully. ${playlistItems.length} items saved.`);
              console.log('Saved to:', outputPath);
              
              // 更新されたファイルの内容を確認用に出力
              playlistItems.forEach((item, index) => {
                console.log(`${index + 1}. ${item.title} by ${item.channelTitle}`);
              });
              
            } catch (error) {
              console.error('Error updating playlist:', error);
              process.exit(1);
            }
          }
          
          updatePlaylist();
          EOF
      
      - name: Run playlist update
        env:
          YOUTUBE_API_KEY: ${{ secrets.YOUTUBE_API_KEY }}
          YOUTUBE_PLAYLIST_ID: ${{ secrets.YOUTUBE_PLAYLIST_ID }}
        run: node update-playlist.mjs
      
      - name: Check for changes
        id: verify-changed-files
        run: |
          if [ -n "$(git status --porcelain)" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            echo "changed=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Set branch name
        id: set-branch-name
        if: steps.verify-changed-files.outputs.changed == 'true'
        run: |
          BRANCH_NAME="playlist-update-$(date +%Y%m%d-%H%M%S)"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
      
      - name: Create Pull Request
        if: steps.verify-changed-files.outputs.changed == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_BODY: "This PR updates the YouTube playlist data automatically."
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git checkout -b ${{ steps.set-branch-name.outputs.branch_name }}
          
          # Clean up temporary script file
          rm -f update-playlist.mjs
          
          # Commit changes
          git add public/data/playlist.json
          git commit -m "Update YouTube playlist data [automated]"
          
          # Push branch
          git push origin ${{ steps.set-branch-name.outputs.branch_name }}
          
          # Create PR using GitHub CLI
          gh pr create \
            --title "Update YouTube playlist data [automated]" \
            --body "$PR_BODY" \
            --base master \
            --head ${{ steps.set-branch-name.outputs.branch_name }}
      
      - name: Auto-merge Pull Request
        if: steps.verify-changed-files.outputs.changed == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Wait a moment for PR to be fully created
          sleep 10
          
          # Enable auto-merge with squash and delete branch
          gh pr merge ${{ steps.set-branch-name.outputs.branch_name }} --auto --squash --delete-branch
      
      - name: Wait for PR merge and trigger deploy
        if: steps.verify-changed-files.outputs.changed == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Waiting for PR to be merged..."
          sleep 30
          
          # Trigger deployment workflow
          echo "Triggering deployment workflow..."
          gh workflow run deploy.yml
          
          echo "Playlist updated and deployment triggered successfully!"
      
      - name: No changes detected
        if: steps.verify-changed-files.outputs.changed == 'false'
        run: echo "No changes in playlist data detected."